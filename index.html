<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile Minion FPS: Enemy Attack</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* HPバー */
        #hp-container {
            position: absolute; bottom: 20px; left: 180px; /* ジョイスティックの右 */
            width: 200px; height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
        }
        #hp-bar {
            width: 100%; height: 100%;
            background: #00ff00;
            transition: width 0.2s, background 0.2s;
        }
        #hp-text {
            position: absolute; bottom: 45px; left: 180px;
            color: white; font-weight: bold; font-size: 14px;
            text-shadow: 1px 1px 1px black;
        }

        /* ダメージエフェクト */
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none;
            transition: opacity 0.1s;
            z-index: 5;
        }

        /* ゲームオーバー画面 */
        #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(50, 0, 0, 0.8);
            color: white;
            display: none; /* 初期は非表示 */
            flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 200; pointer-events: auto;
        }
        #retry-btn {
            margin-top: 20px; padding: 10px 30px; font-size: 20px;
            background: white; color: black; border: none; border-radius: 5px;
            cursor: pointer;
        }

        /* 以下、既存スタイル */
        #score-board {
            position: absolute; top: 20px; left: 20px;
            color: #ffd700; text-shadow: 1px 1px 2px black;
            font-size: 24px; font-weight: bold; font-family: monospace;
            background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px;
        }

        #shop-ui {
            position: absolute; top: 10px; right: 10px;
            display: flex; flex-direction: column; gap: 5px;
            pointer-events: auto; z-index: 100; 
            background: rgba(0,0,0,0.3); padding: 5px; border-radius: 8px;
        }
        .shop-row { display: flex; align-items: center; gap: 5px; }
        .shop-label { color: white; font-size: 12px; font-weight: bold; width: 50px; text-align: right; text-shadow: 1px 1px 1px black; }
        .shop-btn {
            background: rgba(0,0,0,0.6); color: white; border: 1px solid white; border-radius: 5px;
            padding: 5px; font-size: 11px; display: flex; flex-direction: column; align-items: center; justify-content: center;
            width: 50px; height: 35px; cursor: pointer; transition: 0.2s;
        }
        .shop-btn:active { transform: scale(0.95); background: rgba(255,255,255,0.2); }
        .shop-btn.disabled { opacity: 0.4; pointer-events: none; border-color: #555; background: #222; }
        .shop-btn.bulk { border-color: #ffd700; color: #ffd700; width: 55px; }
        #shop-toggle {
            background: rgba(0,0,0,0.8); color: #ffd700; border: 1px solid #ffd700;
            border-radius: 5px; padding: 5px 10px; font-size: 12px; font-weight: bold;
            text-align: center; cursor: pointer; margin-bottom: 5px; align-self: flex-end; width: 100%;
        }
        #shop-list { display: flex; flex-direction: column; gap: 5px; }
        #shop-list.closed { display: none; }

        #weapon-selector {
            position: absolute; bottom: 150px; right: 120px;
            background: rgba(0,0,0,0.5); padding: 10px;
            border-radius: 20px; border: 2px solid rgba(255,255,255,0.5);
            display: flex; align-items: center; gap: 10px;
            pointer-events: auto; z-index: 100; 
        }
        #ws-icon { width: 20px; height: 20px; border-radius: 50%; background: red; box-shadow: 0 0 5px white; }
        #ws-name { color: white; font-weight: bold; font-size: 14px; width: 60px; text-align: center;}
        #ws-count { color: #00ff00; font-weight: bold; font-size: 18px; min-width: 30px; text-align: right;}
        .arrow-btn { color: white; font-size: 18px; padding: 0 10px; cursor: pointer; }

        #reload-msg {
            position: absolute; bottom: 250px; left: 50%; transform: translateX(-50%);
            color: yellow; font-weight: bold; font-size: 18px; display: none; text-shadow: 1px 1px 2px black;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%; transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.2);
        }
        .control-ui { pointer-events: auto; }
        #joystick-zone {
            position: absolute; bottom: 50px; left: 40px; width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; z-index: 100;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.5); border-radius: 50%; transform: translate(-50%, -50%);
        }
        #btn-throw {
            position: absolute; bottom: 60px; right: 30px; width: 80px; height: 80px;
            background: rgba(200, 200, 200, 0.6); border: 4px solid white; border-radius: 50%;
            color: white; font-weight: bold; display: flex; align-items: center; justify-content: center;
            font-size: 16px; box-shadow: 0 0 15px rgba(0,0,0,0.5); text-shadow: 1px 1px 2px black; transition: background 0.2s; z-index: 100;
        }
        #btn-throw:active { transform: scale(0.95); }
        #btn-throw.empty { background: #333 !important; opacity: 0.7; border-color: #555; }
        #btn-call {
            position: absolute; bottom: 160px; right: 30px; width: 60px; height: 60px;
            background: rgba(50, 50, 255, 0.6); border: 2px solid white; border-radius: 50%;
            color: white; font-weight: bold; display: flex; align-items: center; justify-content: center;
            font-size: 12px; box-shadow: 0 0 10px rgba(0,0,0,0.5); z-index: 100;
        }
        #btn-call:active { background: rgba(50, 50, 255, 0.9); transform: scale(0.95); }
        #touch-look-zone { position: absolute; top: 0; right: 0; width: 60%; height: 100%; z-index: 20;}
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); color: white;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; z-index: 200; pointer-events: auto;
            flex-direction: column; text-align: center; gap: 20px;
        }
    </style>
</head>
<body>
    <div id="damage-overlay"></div>

    <div id="ui-layer">
        <div id="score-board">$<span id="score-val">0</span></div>

        <div id="shop-ui">
            <div id="shop-toggle">SHOP ▲</div>
            <div id="shop-list">
                <div class="shop-row">
                    <div class="shop-label" style="color:#ffaaaa">Normal</div>
                    <div class="shop-btn" data-type="NORMAL" data-cost="5" data-mul="1"><div>x1</div><div>$5</div></div>
                    <div class="shop-btn bulk" data-type="NORMAL" data-cost="5" data-mul="10"><div>x10</div><div>$50</div></div>
                </div>
                <div class="shop-row">
                    <div class="shop-label" style="color:#aaffff">Frost</div>
                    <div class="shop-btn" data-type="FROST" data-cost="20" data-mul="1"><div>x1</div><div>$20</div></div>
                    <div class="shop-btn bulk" data-type="FROST" data-cost="20" data-mul="10"><div>x10</div><div>$200</div></div>
                </div>
                <div class="shop-row">
                    <div class="shop-label" style="color:#aaffaa">Glue</div>
                    <div class="shop-btn" data-type="GLUE" data-cost="30" data-mul="1"><div>x1</div><div>$30</div></div>
                    <div class="shop-btn bulk" data-type="GLUE" data-cost="30" data-mul="10"><div>x10</div><div>$300</div></div>
                </div>
                <div class="shop-row">
                    <div class="shop-label" style="color:#aaaaaa">Bomb</div>
                    <div class="shop-btn" data-type="BOMB" data-cost="50" data-mul="1"><div>x1</div><div>$50</div></div>
                    <div class="shop-btn bulk" data-type="BOMB" data-cost="50" data-mul="10"><div>x10</div><div>$500</div></div>
                </div>
            </div>
        </div>

        <div id="weapon-selector">
            <div class="arrow-btn" id="ws-prev">◀</div>
            <div id="ws-icon"></div>
            <div id="ws-name">NORMAL</div>
            <div id="ws-count">10</div>
            <div class="arrow-btn" id="ws-next">▶</div>
        </div>

        <!-- HPバー -->
        <div id="hp-text">HP: 100</div>
        <div id="hp-container">
            <div id="hp-bar"></div>
        </div>

        <div id="reload-msg">RECALLING!</div>
        <div id="crosshair"></div>
        <div id="joystick-zone" class="control-ui"><div id="joystick-knob"></div></div>
        <div id="touch-look-zone" class="control-ui"></div>
        <div id="btn-throw" class="control-ui">FIRE</div>
        <div id="btn-call" class="control-ui">COME</div>
    </div>

    <div id="start-screen">
        <div>MINION FPS: SURVIVAL</div>
        <div style="font-size: 14px; opacity: 0.8; line-height: 1.6; margin-top: 10px;">
            敵も攻撃してきます！<br>移動して弾を避けよう<br><br>TAP TO START
        </div>
    </div>

    <div id="game-over-screen">
        <div style="font-size: 40px; color: red; font-weight: bold;">GAME OVER</div>
        <div style="margin-top: 10px;">Score: $<span id="final-score">0</span></div>
        <button id="retry-btn">RETRY</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';

        const socket = io();
        let camera, scene, renderer;
        let prevTime = performance.now();
        
        let score = 0;
        let currentWeaponIndex = 0;
        let playerHP = 100;
        const MAX_PLAYER_HP = 100;
        let isGameOver = false;

        // Multiplayer variables
        const otherPlayers = {};

        socket.on('connect', () => {
            console.log('Connected to server!', socket.id);
        });

        socket.on('currentPlayers', (players) => {
            Object.keys(players).forEach((id) => {
                if (id !== socket.id) {
                    const playerData = players[id];
                    addOtherPlayer(playerData);
                }
            });
        });

        socket.on('newPlayer', (playerData) => {
            addOtherPlayer(playerData);
        });

        socket.on('playerDisconnected', (id) => {
            if (otherPlayers[id]) {
                scene.remove(otherPlayers[id].mesh);
                // TODO: Also need to dispose geometries and materials
                delete otherPlayers[id];
            }
        });

        socket.on('playerMoved', (playerData) => {
            if (otherPlayers[playerData.id]) {
                otherPlayers[playerData.id].mesh.position.copy(playerData.position);
                // Note: camera rotation is YXZ, so we just care about the Y for the body.
                otherPlayers[playerData.id].mesh.rotation.y = playerData.rotation.y;
                // Maybe rotate head on X axis?
                const head = otherPlayers[playerData.id].mesh.children[0];
                if(head) head.rotation.x = playerData.rotation.x;
            }
        });

        function addOtherPlayer(playerData) {
            // Using a simplified version of the Target mesh for now
            const playerGroup = new THREE.Group();
            playerGroup.position.copy(playerData.position);
            scene.add(playerGroup);

            const skinMat = new THREE.MeshStandardMaterial({color: 0x00ff00}); // Green to differentiate
            const shirtMat = new THREE.MeshStandardMaterial({color: 0xff8800});

            const head = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), skinMat);
            head.position.y = 3.0;
            playerGroup.add(head);

            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.5), shirtMat);
            body.position.y = 1.75;
            playerGroup.add(body);

            otherPlayers[playerData.id] = {
                id: playerData.id,
                mesh: playerGroup
            };
            console.log("Added other player:", playerData.id);
        }

        const inventory = { NORMAL: 10, FROST: 0, GLUE: 0, BOMB: 0 };
        const TYPES = {
            NORMAL: { key: 'NORMAL', color: 0xff0000, name: 'NORMAL', dmg: 1, uiColor: 'rgba(255,50,50,0.8)' },
            FROST:  { key: 'FROST',  color: 0x00ffff, name: 'FROST',  dmg: 0.5, uiColor: 'rgba(0,255,255,0.8)' },
            GLUE:   { key: 'GLUE',   color: 0x00ff00, name: 'GLUE',   dmg: 0, uiColor: 'rgba(50,200,50,0.8)' },
            BOMB:   { key: 'BOMB',   color: 0x222222, name: 'BOMB',   dmg: 5, uiColor: 'rgba(50,50,50,0.8)' }
        };
        const TYPE_KEYS = Object.keys(TYPES);

        const activeMinions = [];
        const enemyProjectiles = []; // 敵の弾
        const targets = [];
        
        const PLAYER_HEIGHT = 3.0; 
        const PLAYER_SPEED = 15.0;
        
        const input = { moveX: 0, moveY: 0 };
        let camRotation = { x: 0, y: 0 };
        let lastSentTime = 0;
        let lastSentRotation = { x: 0, y: 0 };

        // --- クラス定義 ---

        // 敵の弾丸クラス
        class EnemyProjectile {
            constructor(scene, startPos, targetPos) {
                this.mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x220022 }) // 黒っぽい玉
                );
                this.mesh.position.copy(startPos);
                scene.add(this.mesh);

                // プレイヤーへ向けて発射
                const dir = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
                this.velocity = dir.multiplyScalar(20.0); // 弾速
                this.velocity.y += 5.0; // 少し山なり
                this.active = true;
                this.lifeTime = 3.0; // 3秒で消滅
            }

            update(dt, playerPos) {
                if (!this.active) return false;

                this.lifeTime -= dt;
                if (this.lifeTime <= 0) {
                    this.dispose();
                    return false;
                }

                // 物理移動
                this.velocity.y -= 20 * dt; // 重力
                this.mesh.position.addScaledVector(this.velocity, dt);

                // 地面
                if (this.mesh.position.y < 0.5) {
                    this.dispose();
                    return false;
                }

                // プレイヤーとの当たり判定
                // プレイヤーは camera.position (高さ3.0)
                // 足元〜頭まで判定したいので、XZ距離で判定し、Yもある程度見る
                const distXZ = Math.sqrt(
                    Math.pow(this.mesh.position.x - playerPos.x, 2) +
                    Math.pow(this.mesh.position.z - playerPos.z, 2)
                );
                
                if (distXZ < 1.0 && this.mesh.position.y < PLAYER_HEIGHT + 1 && this.mesh.position.y > 0) {
                    takePlayerDamage(10);
                    this.dispose();
                    return false;
                }

                return true;
            }

            dispose() {
                this.active = false;
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        class Minion {
            constructor(scene, typeKey, startPos) {
                this.typeKey = typeKey;
                this.typeData = TYPES[typeKey];
                this.state = 'THROWN'; 
                
                let geo = new THREE.SphereGeometry(0.5, 16, 16);
                this.mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: this.typeData.color }));
                this.mesh.position.copy(startPos);
                this.mesh.position.y -= 1.0;
                scene.add(this.mesh);

                const leafColor = (typeKey === 'BOMB') ? 0xffaa00 : 0x00ff00;
                const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.5, 8), new THREE.MeshBasicMaterial({color: leafColor}));
                leaf.position.y = 0.5;
                this.mesh.add(leaf);

                this.velocity = new THREE.Vector3(0, 0, 0);
                this.attachedTarget = null;
                this.attachTime = 0;
                this.attachOffset = new THREE.Vector3();
            }

            update(dt, playerPos) {
                if (this.state === 'THROWN' || this.state === 'BOUNCING') {
                    this.velocity.y -= 30 * dt;
                    this.mesh.position.addScaledVector(this.velocity, dt);

                    if (this.mesh.position.y < 0.5) {
                        if (this.typeKey === 'BOMB' && this.state === 'THROWN') this.explode();
                        else {
                            this.mesh.position.y = 0.5;
                            this.velocity.set(0, 0, 0);
                            this.state = 'STUCK';
                        }
                    }

                    if (this.state === 'THROWN') {
                        for (let target of targets) {
                            if (target.active && this.mesh.position.distanceTo(target.mesh.position) < 3) {
                                this.onHit(target);
                                break; 
                            }
                        }
                    }

                } else if (this.state === 'ATTACHED') {
                    if (this.attachedTarget && this.attachedTarget.active) {
                        this.mesh.position.copy(this.attachedTarget.mesh.position).add(this.attachOffset);
                        this.attachTime += dt;
                        if (this.attachTime > 3.0) this.detach();
                    } else {
                        this.detach();
                    }

                } else if (this.state === 'RETURNING') {
                    const returnSpeed = 45.0;
                    const targetPos = new THREE.Vector3(playerPos.x, 0.5, playerPos.z);
                    const dir = new THREE.Vector3().subVectors(targetPos, this.mesh.position);
                    const distXZ = Math.sqrt(dir.x * dir.x + dir.z * dir.z);
                    dir.normalize();
                    this.mesh.position.addScaledVector(dir, returnSpeed * dt);
                    this.mesh.position.y = 0.5 + Math.abs(Math.sin(performance.now() * 0.02)) * 1.5;
                    if (distXZ < 5.0) return true;
                }
                return false;
            }

            onHit(target) {
                if (this.typeKey === 'BOMB') this.explode();
                else if (this.typeKey === 'GLUE') {
                    this.state = 'ATTACHED';
                    this.attachedTarget = target;
                    this.attachTime = 0;
                    this.attachOffset.subVectors(this.mesh.position, target.mesh.position);
                    target.addGlueMinion(this);
                } else if (this.typeKey === 'FROST') {
                    target.hit(this.typeData.dmg);
                    target.applySlow();
                    this.bounceOff();
                } else {
                    target.hit(this.typeData.dmg);
                    this.bounceOff();
                }
            }

            bounceOff() {
                this.velocity.set((Math.random()-0.5)*10, 10, (Math.random()-0.5)*10);
                this.state = 'BOUNCING';
            }

            explode() {
                const range = 8.0;
                for (let t of targets) {
                    if (t.active && this.mesh.position.distanceTo(t.mesh.position) < range) {
                        t.hit(this.typeData.dmg);
                    }
                }
                const blast = new THREE.Mesh(new THREE.SphereGeometry(range/2, 8, 8), new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0.8}));
                blast.position.copy(this.mesh.position);
                scene.add(blast);
                let scale = 1.0;
                const blastAnim = () => {
                    scale += 0.2; blast.scale.setScalar(scale); blast.material.opacity -= 0.1;
                    if (blast.material.opacity > 0) requestAnimationFrame(blastAnim); else scene.remove(blast);
                };
                blastAnim();
                this.velocity.set(0,0,0);
                this.mesh.position.y = 0.5;
                this.state = 'STUCK';
            }

            detach() {
                this.state = 'STUCK';
                this.mesh.position.y = 0.5;
                this.attachedTarget = null;
            }

            callBack() {
                if (this.state === 'ATTACHED') this.detach();
                this.state = 'RETURNING';
            }

            dispose() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        class Target {
            constructor(scene, x, z) {
                this.maxHp = 20; this.hp = this.maxHp; this.active = true;
                this.baseSpeed = 4.0; this.currentSpeed = this.baseSpeed;
                this.slowTimer = 0; this.glueMinions = []; this.glueTickTimer = 0;
                this.animTime = Math.random() * 100;
                this.attackTimer = Math.random() * 2; // 攻撃用タイマー

                this.mesh = new THREE.Group();
                this.mesh.position.set(x, 0, z);
                scene.add(this.mesh);

                const skinMat = new THREE.MeshStandardMaterial({color: 0xffccaa});
                const shirtMat = new THREE.MeshStandardMaterial({color: 0x0088ff});
                const pantsMat = new THREE.MeshStandardMaterial({color: 0x000088});

                const head = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), skinMat);
                head.position.y = 3.0;
                const eyeGeo = new THREE.BoxGeometry(0.2, 0.2, 0.1);
                const eyeMat = new THREE.MeshBasicMaterial({color: 0x000000});
                const eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-0.2, 0, 0.5); head.add(eyeL);
                const eyeR = new THREE.Mesh(eyeGeo, eyeMat); eyeR.position.set(0.2, 0, 0.5); head.add(eyeR);
                this.mesh.add(head);
                this.head = head;

                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.5), shirtMat);
                body.position.y = 1.75; this.mesh.add(body);

                this.armLGroup = new THREE.Group(); this.armLGroup.position.set(-0.65, 2.4, 0);
                const armL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.5, 0.3), skinMat); armL.position.y = -0.6;
                this.armLGroup.add(armL); this.mesh.add(this.armLGroup);

                this.armRGroup = new THREE.Group(); this.armRGroup.position.set(0.65, 2.4, 0);
                const armR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.5, 0.3), skinMat); armR.position.y = -0.6;
                this.armRGroup.add(armR); this.mesh.add(this.armRGroup);

                this.legLGroup = new THREE.Group(); this.legLGroup.position.set(-0.25, 1.0, 0);
                const legL = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.5, 0.35), pantsMat); legL.position.y = -0.75;
                this.legLGroup.add(legL); this.mesh.add(this.legLGroup);

                this.legRGroup = new THREE.Group(); this.legRGroup.position.set(0.25, 1.0, 0);
                const legR = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.5, 0.35), pantsMat); legR.position.y = -0.75;
                this.legRGroup.add(legR); this.mesh.add(this.legRGroup);

                this.frostMesh = new THREE.Mesh(new THREE.BoxGeometry(1.5, 4, 1.5), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.0 }));
                this.frostMesh.position.y = 2.0; this.mesh.add(this.frostMesh);

                this.hpGroup = new THREE.Group(); this.hpGroup.position.set(0, 4.2, 0); this.mesh.add(this.hpGroup);
                const bgGeo = new THREE.PlaneGeometry(3, 0.3); this.hpGroup.add(new THREE.Mesh(bgGeo, new THREE.MeshBasicMaterial({ color: 0x330000 })));
                const barGeo = new THREE.PlaneGeometry(3, 0.3); barGeo.translate(1.5, 0, 0); 
                this.hpBar = new THREE.Mesh(barGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
                this.hpBar.position.x = -1.5; this.hpGroup.add(this.hpBar);
            }

            update(dt, camera) {
                if (!this.active) return;
                this.hpGroup.lookAt(camera.position);

                // 状態異常処理
                if (this.slowTimer > 0) {
                    this.slowTimer -= dt;
                    this.currentSpeed = this.baseSpeed * 0.4;
                    this.frostMesh.material.opacity = 0.5;
                } else {
                    this.currentSpeed = this.baseSpeed;
                    this.frostMesh.material.opacity = 0.0;
                }
                this.glueTickTimer += dt;
                if (this.glueTickTimer > 1.0) {
                    this.glueMinions = this.glueMinions.filter(m => m.state === 'ATTACHED' && m.attachedTarget === this);
                    if (this.glueMinions.length > 0) {
                        this.hit(this.glueMinions.length * 1);
                        this.flash(0x00ff00);
                    }
                    this.glueTickTimer = 0;
                }

                const playerPos = camera.position;
                const dx = playerPos.x - this.mesh.position.x;
                const dz = playerPos.z - this.mesh.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);

                // 攻撃ロジック
                this.attackTimer += dt;
                if (this.attackTimer > 3.0) { // 3秒に1回攻撃
                    if (dist < 30) { // 射程内なら
                        this.shoot(playerPos);
                        this.attackTimer = 0;
                    }
                }

                // 移動
                this.animTime += dt * (this.currentSpeed * 1.5);
                const angle = Math.sin(this.animTime) * 0.8;
                this.legLGroup.rotation.x = angle; this.legRGroup.rotation.x = -angle;
                this.armLGroup.rotation.x = -angle; this.armRGroup.rotation.x = angle;

                if (dist > 5.0) { // プレイヤーに近づきすぎない
                    const vx = (dx / dist) * this.currentSpeed * dt;
                    const vz = (dz / dist) * this.currentSpeed * dt;
                    this.mesh.position.x += vx;
                    this.mesh.position.z += vz;
                    const targetAngle = Math.atan2(dx, dz);
                    this.mesh.rotation.y = targetAngle;
                }
            }

            shoot(targetPos) {
                // 弾を発射
                const startPos = this.mesh.position.clone();
                startPos.y += 2.0; // 胸あたりから発射
                // 敵より少し前に出す（自分に当たらないように）
                const dir = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
                startPos.addScaledVector(dir, 1.5);

                const projectile = new EnemyProjectile(scene, startPos, targetPos);
                enemyProjectiles.push(projectile);
            }

            hit(damage) {
                if(!this.active) return;
                this.hp -= damage;
                const ratio = Math.max(0, this.hp / this.maxHp);
                this.hpBar.scale.x = ratio;
                this.flash(0xffffff);
                if (this.hp <= 0) this.die();
            }

            flash(colorHex) {
                this.mesh.traverse((child) => {
                    if (child.isMesh && child !== this.frostMesh && child !== this.hpBar) {
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(colorHex);
                            setTimeout(() => { if(this.active && child.material) child.material.emissive.setHex(0x000000); }, 50);
                        }
                    }
                });
            }

            applySlow() { this.slowTimer = 3.0; }
            addGlueMinion(minion) { this.glueMinions.push(minion); }

            die() {
                this.active = false;
                this.mesh.visible = false;
                this.mesh.position.y = -100;
                for (let m of this.glueMinions) if(m.state === 'ATTACHED') m.detach();
                addScore(100);
                setTimeout(() => { this.respawn(camera); }, 5000);
            }

            respawn(camera) {
                this.active = true;
                this.hp = this.maxHp;
                this.hpBar.scale.x = 1.0;
                this.mesh.visible = true;
                this.mesh.traverse((child) => { if(child.isMesh && child.material && child.material.emissive) child.material.emissive.setHex(0x000000); });
                this.slowTimer = 0;
                this.attackTimer = Math.random() * 2;
                const angle = Math.random() * Math.PI * 2;
                const dist = 30 + Math.random() * 20;
                this.mesh.position.set(camera.position.x + Math.cos(angle)*dist, 0, camera.position.z + Math.sin(angle)*dist);
            }
        }

        init();
        setupControls();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 80);
            scene.add(new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10); scene.add(dirLight);

            const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x44aa44 }));
            floor.rotation.x = -Math.PI / 2; scene.add(floor);

            for(let i=0; i<15; i++) {
                const tree = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 6), new THREE.MeshStandardMaterial({color: 0x8B4513}));
                const angle = Math.random() * Math.PI * 2; const rad = 30 + Math.random() * 60;
                tree.position.set(Math.cos(angle)*rad, 3, Math.sin(angle)*rad); scene.add(tree);
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(3, 6, 8), new THREE.MeshStandardMaterial({color: 0x228B22}));
                leaves.position.y = 5; tree.add(leaves);
            }

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, PLAYER_HEIGHT, 10);
            camera.rotation.order = "YXZ";
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            targets.push(new Target(scene, 0, -40));
            targets.push(new Target(scene, 30, -30));
            targets.push(new Target(scene, -30, -30));
            targets.push(new Target(scene, -10, -60));

            window.addEventListener('resize', onWindowResize);
            document.getElementById('start-screen').addEventListener('click', function() { this.style.display = 'none'; });
            
            document.getElementById('retry-btn').addEventListener('click', resetGame);
            
            updateWeaponUI();
            updateShopUI();
            updatePlayerHPUI();
        }

        function updatePlayerHPUI() {
            const bar = document.getElementById('hp-bar');
            const text = document.getElementById('hp-text');
            const pct = Math.max(0, (playerHP / MAX_PLAYER_HP) * 100);
            bar.style.width = pct + '%';
            text.innerText = 'HP: ' + playerHP;
            
            if (pct > 50) bar.style.background = '#00ff00';
            else if (pct > 20) bar.style.background = '#ffff00';
            else bar.style.background = '#ff0000';
        }

        function takePlayerDamage(dmg) {
            if (isGameOver) return;
            playerHP -= dmg;
            updatePlayerHPUI();

            // ダメージエフェクト
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 0.5;
            setTimeout(() => { overlay.style.opacity = 0; }, 100);

            if (playerHP <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            isGameOver = true;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        function resetGame() {
            isGameOver = false;
            playerHP = 100;
            score = 0;
            updatePlayerHPUI();
            addScore(0); // UI更新のため

            // ミニオンリセット（インベントリは初期化せず維持してもいいが、ここでは初期化）
            inventory.NORMAL = 10; inventory.FROST = 0; inventory.GLUE = 0; inventory.BOMB = 0;
            updateWeaponUI();
            
            // フィールドクリア
            for(let m of activeMinions) m.dispose();
            activeMinions.length = 0;
            for(let p of enemyProjectiles) p.dispose();
            enemyProjectiles.length = 0;

            // 敵配置リセット
            for(let t of targets) t.die(); // 一旦消してリスポーン待機させるか、強制リスポーン
            // 即時リスポーン
            for(let t of targets) t.respawn(camera);

            // カメラ位置リセット
            camera.position.set(0, PLAYER_HEIGHT, 10);
            camRotation = {x:0, y:0};

            document.getElementById('game-over-screen').style.display = 'none';
        }

        function addScore(val) {
            score += val;
            document.getElementById('score-val').innerText = score;
            updateShopUI();
        }

        function updateShopUI() {
            const btns = document.querySelectorAll('.shop-btn');
            btns.forEach(btn => {
                const baseCost = parseInt(btn.dataset.cost);
                const mul = parseInt(btn.dataset.mul);
                const totalCost = baseCost * mul;
                if (score >= totalCost) btn.classList.remove('disabled'); else btn.classList.add('disabled');
            });
        }

        function updateWeaponUI() {
            const currentKey = TYPE_KEYS[currentWeaponIndex];
            const typeData = TYPES[currentKey];
            const count = inventory[currentKey];
            document.getElementById('ws-name').innerText = typeData.name;
            document.getElementById('ws-icon').style.background = '#' + typeData.color.toString(16).padStart(6, '0');
            document.getElementById('ws-count').innerText = count;
            const fireBtn = document.getElementById('btn-throw');
            fireBtn.style.background = typeData.uiColor;
            if (count <= 0) { fireBtn.classList.add('empty'); fireBtn.innerText = "EMPTY"; }
            else { fireBtn.classList.remove('empty'); fireBtn.innerText = "FIRE"; }
        }

        function setupControls() {
            const joystickZone = document.getElementById('joystick-zone');
            const joystickKnob = document.getElementById('joystick-knob');
            let joyStartX = 0, joyStartY = 0;
            
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                joyStartX = touch.clientX; joyStartY = touch.clientY;
            }, {passive: false});

            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                let dx = touch.clientX - joyStartX; let dy = touch.clientY - joyStartY;
                const maxDist = 60; const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > maxDist) { dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; }
                joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                input.moveX = dx / maxDist; input.moveY = dy / maxDist;
            }, {passive: false});

            const resetJoy = (e) => {
                e.preventDefault(); input.moveX = 0; input.moveY = 0;
                joystickKnob.style.transform = `translate(-50%, -50%)`;
            };
            joystickZone.addEventListener('touchend', resetJoy); joystickZone.addEventListener('touchcancel', resetJoy);

            const lookZone = document.getElementById('touch-look-zone');
            let lookStartX = 0, lookStartY = 0;
            lookZone.addEventListener('touchstart', (e) => {
                lookStartX = e.changedTouches[0].clientX; lookStartY = e.changedTouches[0].clientY;
            }, {passive: false});
            lookZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const t = e.changedTouches[0];
                const sensitivity = 0.005;
                camRotation.y -= (t.clientX - lookStartX) * sensitivity;
                camRotation.x -= (t.clientY - lookStartY) * sensitivity;
                camRotation.x = Math.max(-1.4, Math.min(1.4, camRotation.x));
                lookStartX = t.clientX; lookStartY = t.clientY;
            }, {passive: false});

            document.getElementById('ws-prev').addEventListener('click', () => {
                currentWeaponIndex = (currentWeaponIndex - 1 + TYPE_KEYS.length) % TYPE_KEYS.length;
                updateWeaponUI();
            });
            document.getElementById('ws-next').addEventListener('click', () => {
                currentWeaponIndex = (currentWeaponIndex + 1) % TYPE_KEYS.length;
                updateWeaponUI();
            });
            document.getElementById('weapon-selector').addEventListener('click', (e) => {
                if(e.target.classList.contains('arrow-btn')) return;
                currentWeaponIndex = (currentWeaponIndex + 1) % TYPE_KEYS.length;
                updateWeaponUI();
            });

            const shopToggle = document.getElementById('shop-toggle');
            const shopList = document.getElementById('shop-list');
            const toggleShop = (e) => {
                e.preventDefault(); e.stopPropagation();
                shopList.classList.toggle('closed');
                shopToggle.innerText = shopList.classList.contains('closed') ? 'SHOP ▼' : 'SHOP ▲';
            };
            shopToggle.addEventListener('touchstart', toggleShop, {passive: false});
            shopToggle.addEventListener('mousedown', toggleShop);

            const buyAction = (e, btn) => {
                e.stopPropagation();
                const type = btn.dataset.type;
                const baseCost = parseInt(btn.dataset.cost);
                const mul = parseInt(btn.dataset.mul);
                const totalCost = baseCost * mul;
                if (score >= totalCost) {
                    addScore(-totalCost);
                    inventory[type] += mul;
                    updateWeaponUI();
                    btn.style.backgroundColor = "white";
                    setTimeout(() => btn.style.backgroundColor = "rgba(0,0,0,0.6)", 100);
                }
            };
            document.querySelectorAll('.shop-btn').forEach(btn => {
                btn.addEventListener('touchstart', (e) => buyAction(e, btn), {passive: false});
                btn.addEventListener('mousedown', (e) => buyAction(e, btn)); 
            });

            const throwBtn = document.getElementById('btn-throw');
            const throwAction = (e) => {
                e.preventDefault(); e.stopPropagation();
                if(isGameOver) return;
                const currentKey = TYPE_KEYS[currentWeaponIndex];
                if (inventory[currentKey] > 0) {
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    const m = new Minion(scene, currentKey, camera.position);
                    m.velocity.copy(camDir).multiplyScalar(40);
                    m.velocity.y += 5;
                    activeMinions.push(m);
                    inventory[currentKey]--;
                    updateWeaponUI();
                }
            };
            throwBtn.addEventListener('touchstart', throwAction); throwBtn.addEventListener('mousedown', throwAction);

            const callBtn = document.getElementById('btn-call');
            const callAction = (e) => {
                e.preventDefault(); e.stopPropagation();
                if(isGameOver) return;
                let called = false;
                for (let m of activeMinions) { m.callBack(); called = true; }
                if(called) {
                    const msg = document.getElementById('reload-msg');
                    msg.style.display = 'block';
                    setTimeout(() => { msg.style.display = 'none'; }, 1000);
                }
            };
            callBtn.addEventListener('touchstart', callAction); callBtn.addEventListener('mousedown', callAction);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const dt = Math.min((time - prevTime) / 1000, 0.1);
            prevTime = time;

            // Emit player movement
            if (socket && socket.connected && (input.moveX !== 0 || input.moveY !== 0 || lastSentRotation.x !== camRotation.x || lastSentRotation.y !== camRotation.y)) {
                // Throttle updates to ~30 times per second
                if (time - lastSentTime > 33) {
                    socket.emit('playerMovement', {
                        position: camera.position,
                        rotation: {x: camRotation.x, y: camRotation.y, z: 0} // z is not used
                    });
                    lastSentTime = time;
                    lastSentRotation.x = camRotation.x;
                    lastSentRotation.y = camRotation.y;
                }
            }

            if(isGameOver) return;

            camera.rotation.x = camRotation.x;
            camera.rotation.y = camRotation.y;

            if (input.moveX !== 0 || input.moveY !== 0) {
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), camRotation.y);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), camRotation.y);
                const moveDir = new THREE.Vector3();
                moveDir.addScaledVector(forward, -input.moveY);
                moveDir.addScaledVector(right, input.moveX);
                moveDir.normalize();
                camera.position.addScaledVector(moveDir, PLAYER_SPEED * dt);
            }

            // ミニオン更新
            for (let i = activeMinions.length - 1; i >= 0; i--) {
                const m = activeMinions[i];
                const returned = m.update(dt, camera.position);
                if (returned) {
                    inventory[m.typeKey]++;
                    m.dispose();
                    activeMinions.splice(i, 1);
                    updateWeaponUI();
                }
            }

            // 敵の弾更新
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                const alive = p.update(dt, camera.position);
                if (!alive) {
                    enemyProjectiles.splice(i, 1);
                }
            }
            
            // 敵更新
            for (let t of targets) t.update(dt, camera);
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
